@startuml Use Cases



@enduml


@startuml Player Starts Game
hide empty description

[*] --> shuffleDeck : The Player runs \nthe application
shuffleDeck --> generateTableauPiles
generateTableauPiles --> turnUpperCardFromEachPile
turnUpperCardFromEachPile --> OpenGame : The game is presented \nto the Player
@enduml

@startuml Player Flips Deck

state choice1 <<choice>> 
hide empty description 
state "OpenGame" as 0
state "Player asks to refresh the Waste" as 1
state "Put cards in the Waste at the botton of the Deck" as 2
state "Put three Cards from the top of the Deck to the Waste in reverse order" as 3

0 -down-> 1

1 -down-> choice1
choice1 -down-> 2: Movement possible
choice1 -down-> EndGameState: No more possible movements
2 -down-> 3
3-down-> OpenGame
@enduml


@enduml

@startuml Player Moves Card From Waste to Tableau
:OpenGame;
repeat :Player Selects Card in Waste;
repeat while (Valid Card?) is (no)
repeat :Player Selects Card in Tableau;
repeat while (Valid Card?) is (no)
:Display Movement;
:OpenGame;
@enduml

@startuml Player Moves Card From Waste to Foundation

hide empty description 
state c <<choice>>
state d <<choice>>
state e <<choice>>

state "OpenGame" as 0

0 -down-> state1 : Player select Move from Tableau To Tableau
state1 -down-> state2 : System allows to select Card to be moved
state2 -down-> c : Player selects Card to be moved
c --> ShowError : Invalid card
c --> state3 : Valid card
state3 --> d : System allows to select destination Pile
d --> ShowError : Invalid Destination Pile
ShowError -up-> 0
d --> MoveCard : valid destination Pile
MoveCard --> GameEvaluation : Show Board
GameEvaluation --> e : Evaluate Game 
e -left-> ClosedGame : Game Finished
e --> OpenGame: 

@enduml

@startuml States Player Moves Card From Waste to Tableau
hide empty description
state "OpenGame" as 0
0 -down-> _ : Player Selects Card in Waste
state choice <<choice>>
_ --> choice : Is valid card?
choice --> 0 : No
choice --> .:  Yes
. --> Destination : Player selects destination
state choice1 <<choice>>
Destination --> choice1 : Is valid destination?
choice1 --> DisplayGame : Yes
choice1 --> . : No
DisplayGame --> OpenGame
@enduml

@startuml Player Moves Card from Tableau to Foundation
state choice1 <<choice>> 
state choice2 <<choice>>
state choice3 <<choice>> 

hide empty description 
state "Player select card to Move from a Tableau" as 1
state "Player select a Foundation as destination" as 2
state "Board is updated" as 3
state "OpenGame" as 0
0 -down-> 1

1 -down-> choice1
choice1 -down-> 2
choice1 -right-> ShowError : Selected card cannot be move
2-down-> choice2
choice2 -right-> ShowError : Card.Color != Foundation.Color
choice2 -down-> 3
3-down-> choice3
choice3 -right-> Win: All foundations complete
choice3 --> OpenGame: Foundation not complete
ShowError -up-> 0
@enduml

@startuml Player Moves Tableau to Tableu

hide empty description

state c <<choice>>
state d <<choice>>

[*] --> state1 : Player select Move from Tableau To Tableau
state1 --> state2 : System allows to select Card to be moved
state2 --> c : Player selects Card to be moved
c --> ShowError : Invalid card
c --> state3 : Valid card
state3 --> d : System allows to select destination Pile
d --> ShowError : Invalid Destination Pile
ShowError --> [*]
d --> MoveCard : valid destination Pile
MoveCard --> state5 : Show Board
state5 --> [*]

@enduml

@startuml Player Moves Foundation to Tableu

hide empty description

state c <<choice>>
state d <<choice>>

[*] --> state1 : Player select Move from Foundation To Tableau
state1 --> state2 : System allows to select Card to be moved
state2 --> c : Player selects Card to be moved
c --> ShowError : Invalid card
c --> state3 : Valid card
state3 --> d : System allows to select destination Pile
d --> ShowError : Invalid Destination Pile
ShowError --> [*]
d --> MoveCard : valid destination Pile
MoveCard --> state5 : Show Board
state5 --> [*]

@enduml


@startuml Player Request Random Movement
:**Open Game**;
:Player Selects Hint;
:System Calculates Random Legal Movement;
:Display Movement;

if (Game Finished?) then (no)
  :**Open Game**;
  stop
else
  if (Has Win?) then (yes)
    :Show Win;
  else (no)
    :Show Lost;
  endif
  :**Close Game**;
  stop
endif
@enduml

@startuml States Request Random Movement
hide empty description
OpenGame --> S1 : Player selects Hint
S1 --> S2 : Show Game after computed movement
state choice <<choice>>
S2 --> choice : Is game finished?
choice --> S3 : yes
choice --> OpenGame: no
state choice2 <<choice>>
S3 --> choice2 : Has won?
choice2 --> S4 : No
S4 --> GameClosed : System show Lost
choice2 --> S5 : Yes
S5 --> GameClosed : System show Win
@enduml

@startuml Player Restarts Game

hide empty description

state c <<choice>>

[*] --> Confirmation : The Player request to restart game
Confirmation --> c : System asks for confirmation
c --> StartGame : Player confirms restart action
c --> [*] : Player does not confirm restart action
StartGame --> [*]

@enduml

@startuml Player Request Help Summary
hide empty description 
state "Player asks for the help summary" as 1
state "Help summary is show" as 2
OpenGame -down-> 1
1 --> 2
2-up-> OpenGame
@enduml


@enduml

@startuml Player Exits Game
:**OpenGame**;
:Player selects Exit;
:System close application;
end
@enduml

@startuml States Player Exits Game
hide empty description
OpenGame --> S1 : Player Selects Exit
S1 --> [*] : System close application
@enduml

